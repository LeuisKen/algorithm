# 将正方形矩阵顺时针转动 90°

给定一个 N×N 的矩阵 matrix,把这个矩阵调整成顺时针转动 90°后的形式,要求额外空间复杂度为 O(1).

例如:

```
1  2  3  4
5  6  7  8
9  10 11 12
13 14 15 16
```

顺时针转动 90°后为:

```
13 9  5  1
14 10 6  2
15 11 7  3
16 12 8  4
```

## 解答

这里仍使用分圈处理的方式,在矩阵中用左上角的坐标(tR,tC)和右下角的坐标(dR,dC)就可以表示一个子矩阵。比如,题目中的矩阵,当(tR,tC)=(0,0)、(dR,dC)=(3,3)时,表示的子矩阵就是整个矩阵,那么这个子矩阵最外层的部分如下。

```
1  2  3  4
5        8
9        12
13 14 15 16
```

在这个外圈中,1,4,16,13 为一组,然后让 1 占据 4 的位置,4 占据 16 的位置,16占据 13 的位置,13 占据 1 的位置,一组就调整完了。然后 2,8,15,9 为一组,继续占据调整的过程,最后 3,12,14,5 为一组,继续占据调整的过程。然后(tR,tC)=(0,0)、(dR,dC)=(3,3)的子矩阵外层就调整完毕。接下来令 tR 和 tC 加 1,即(tR,tC)=(1,1),令 dR 和dC 减 1,即(dR,dC)=(2,2),此时表示的子矩阵如下。

```
6  7
10 11
```

这个外层只有一组,就是 6,7,11,10,占据调整之后即可。所以,如果子矩阵的大小是 M×M,一共就有 M-1 组,分别进行占据调整即可。

具体过程请参看如下代码中的 rotate 方法。

```js
var rotate = function(matrix) {
  var tR = 0,
      tC = 0,
      dR = matrix.length,
      dC = matrix[0].length
  while(tR < dR) {
    rotateEdge(matrix, tR++, tC++, dR--, dC--)
  }
}

var rotateEdge = function(m, tR, tC, dR, dC) {
  var times = dC - tC,
      tmp = 0
  for(var i = 0; i !== times; i++) {
    tmp = m[tR][tC + i]
    m[tR][tC + i] = m[dR - i][tC]
    m[dR - i][tC] = m[dR][dC - i]
    m[dR][dC - i] = m[tR + i][dC]
    m[tR + i][dC] = tmp
  }
}
```
